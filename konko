#!/usr/bin/env python3

import os
import sys
import lxml.html
from lxml.builder import E
from lxml import etree
import filtering
import naming
import pathabbr
import kconfig
import kexcel
import kstyle
import kutil


class Token:
    def html(self):
        i = self.html_id()
        k = self.html_class()
        attr = {}
        if len(k) > 0:
            attr["class"] = " ".join(k)
        if i is not None:
            attr["id"] = i
        if len(attr) > 0:
            return E.span(self.text, **attr)
        else:
            return self.text

    def process0(self):
        self.delete = False
        self.text = filtering.printable_nl(self.raw)
        self.simpletext = filtering.printable_compact(self.raw)


class Word(Token):
    def html_id(self):
        if self.delete:
            return None
        if len(self.match) == 0:
            return None
        return "l{}c{}".format(self.line, self.char)

    def html_class(self):
        k = []
        if self.delete:
            k.append("del")
        elif len(self.match) > 0:
            k.append("match")
        return k

    def link(self, f):
        i = self.html_id()
        assert i is not None
        return '{}#{}'.format(f.url, i)

    def process(self, conc):
        self.lemma = self.simpletext.lower()
        self.match = []
        for search in conc.search:
            if kutil.exact_match(search.re, self.raw):
                self.match.append(search)

    def set_context(self, f, i, prev):
        assert f.tokens[i] == self
        if prev is None:
            self.tag = None
        else:
            self.tag = prev.simpletext
        self.before = reversed(self.get_context(f, i, -1))
        self.after = self.get_context(f, i, +1)
        self.left = self.get_context_simple(f, i, -1)
        self.right = self.get_context_simple(f, i, +1)

    def get_context(self, f, i, d):
        ctx = []
        j = i + d
        l = 0
        while 0 <= j < len(f.tokens) and l < f.conc.config.context:
            t = f.tokens[j]
            if not t.delete:
                fmt, txt = t.for_context()
                l += len(txt)
                ctx.append((fmt, txt))
            j += d
        return ctx

    def get_context_simple(self, f, i, d):
        CTX_WORDS = 4
        ctx = []
        j = i + d
        while 0 <= j < len(f.tokens) and len(ctx) < CTX_WORDS:
            t = f.tokens[j]
            if not t.delete and isinstance(t, Word):
                ctx.append(t.simpletext.lower())
            j += d
        return ' '.join(ctx)

    def for_context(self):
        if len(self.match) > 0:
            return "hl", self.simpletext
        else:
            return "normal", self.simpletext


class Tag(Token):
    def html_id(self):
        return None

    def html_class(self):
        k = ["tag"]
        if self.delete:
            k.append("del")
        if self.show_prev:
            k.append("show")
        return k

    def descr(self):
        return 'tag {} on line {}, column {}'.format(self.raw, self.line, self.char)

    def process(self, conc):
        self.show_prev = kutil.try_exact_match(conc.config.show_prev, self.raw)
        for a in conc.config.delete:
            if kutil.exact_match(a, self.raw):
                self.delete = True
        self.delete_open = []
        self.delete_close = []
        for i, a in enumerate(conc.config.delete_pair):
            a1, a2 = a
            if kutil.exact_match(a1, self.raw):
                self.delete_open.append(i)
            if kutil.exact_match(a2, self.raw):
                self.delete_close.append(i)

    def for_context(self):
        return "light", self.simpletext


class Sep(Token):
    def html_id(self):
        return None

    def html_class(self):
        return ["sep"]

    def process(self, conc):
        pass

    def for_context(self):
        return "normal", self.simpletext


class File:
    def __init__(self, source, filename, shortname):
        self.source = source
        self.conc = source.conc
        self.filename = filename
        self.shortname = shortname
        self.safename = source.safenames.get(shortname)
        self.htmlfile = self.safename + ".html"
        self.url = source.url + '/' + self.htmlfile
        self.htmlpath = os.path.join(source.htmlpath, self.htmlfile)

    def read(self):
        with open(self.filename, encoding=self.conc.config.encoding) as f:
            self.data = f.read()

    def process(self):
        self.parse()
        self.clean()
        self.report()

    def write(self):
        doc = self.get_html()
        with open(self.htmlpath, "bw") as f:
            f.write(b'<!DOCTYPE html>\n')
            f.write(lxml.html.tostring(doc))
            f.write(b'\n')

    def get_html(self):
        content = [t.html() for t in self.tokens]
        head = E.head(
            E.title(self.shortname),
            E.meta(charset="UTF-8"),
            E.style(kstyle.css),
        )
        body = E.body(E.pre(*content))
        return E.html(head, body, lang="en")

    def parse(self):
        self.tokens = []
        self.line = 1
        self.char = 1
        self.prev = 0
        n = len(self.data)
        while self.prev < n:
            tag = kutil.try_search(self.conc.config.tag, self.data, self.prev)
            word = kutil.try_search(self.conc.config.word, self.data, self.prev)
            if tag is not None and tag.start() < word.start():
                a = tag.start()
                b = tag.end()
                self.feed(Sep, a)
                self.feed(Tag, b)
            elif word is not None:
                a = word.start()
                b = word.end()
                if tag is not None and tag.start() < b:
                    b = tag.start()
                self.feed(Sep, a)
                self.feed(Word, b)
            else:
                self.feed(Sep, n)

    def feed(self, kind, b):
        a = self.prev
        assert a <= b
        self.prev = b
        if a == b:
            return
        raw = self.data[a:b]
        t = kind()
        t.raw = raw
        t.start = a
        t.line = self.line
        t.char = self.char
        t.process0()
        t.process(self.conc)
        self.tokens.append(t)
        for c in raw:
            if c == '\n':
                self.line += 1
                self.char = 1
            else:
                self.char += 1

    def clean(self):
        m = len(self.conc.config.delete_pair)
        stack = [ [] for x in range(m) ]
        delete_range = []
        for j,t in enumerate(self.tokens):
            if isinstance(t, Tag):
                for x in t.delete_open:
                    stack[x].append(j)
                for x in t.delete_close:
                    if len(stack[x]) == 0:
                        self.conc.warn(self.filename, "{}: no matching opening tag".format(t.descr()))
                    else:
                        i = stack[x].pop()
                        delete_range.append((i,j))
        for l in stack:
            for i in l:
                t = self.tokens[i]
                self.conc.warn(self.filename, "{}: no matching closing tag".format(t.descr()))
        for i,j in delete_range:
            for k in range(i,j+1):
                self.tokens[k].delete = True
        self.words = []
        prev = None
        for i,t in enumerate(self.tokens):
            if isinstance(t, Tag) and not t.delete and t.show_prev:
                prev = t
            if isinstance(t, Word) and not t.delete:
                self.words.append(t)
                if len(t.match) > 0:
                    t.set_context(self, i, prev)

    def report(self):
        counts = { s.key: kutil.Counter() for s in self.conc.search }
        for w in self.words:
            for s in w.match:
                counts[s.key].add(w.lemma)
                s.add(w, self)
        self.conc.add(self, len(self.words), counts)


class Source:
    def __init__(self, conc, key, globs):
        self.conc = conc
        self.key = key
        self.globs = globs
        self.safename = conc.safenames.get(key)
        self.safenames = naming.safe_naming()

    def process(self):
        self.url = self.conc.url + '/' + self.safename
        self.htmlpath = os.path.join(self.conc.config.output_dir, self.safename)
        try:
            os.makedirs(self.htmlpath, exist_ok=True)
        except:
            kutil.exception_exit('error creating output directory: {}'.format(self.htmlpath))
        print(self.key, end=' ', flush=True)
        skip = set(kutil.listglob(self.conc.config.skip_files))
        l = kutil.listglob(self.globs)
        l = [x for x in l if x not in skip]
        if len(l) == 0:
            sys.exit("{}: after skipping, there are no files left".format(self.key))
        shortnames = pathabbr.pathabbr(l)
        self.files = []
        for filename in l:
            print('.', end='', flush=True)
            f = File(self, filename, shortnames[filename])
            self.files.append(f)
            try:
                f.read()
            except:
                print()
                kutil.exception_exit('error reading input file: {}'.format(filename))
            f.process()
            try:
                f.write()
            except:
                print()
                kutil.exception_exit('error writing output file: {}'.format(f.htmlfile))
        print()


class Search():
    def __init__(self, conc, key, re):
        self.key = key
        self.re = re
        self.conc = conc

    def get_columns(self):
        return [
            ("N",),
            ("Before", "right"),
            ("Word", "key"),
            ("After",),
            ("Simple",),
            ("Lemma",),
            ("Source",),
            ("File",),
            ("Line",),
            ("Column",),
            ("Tag",),
            ("Left", "light", 10),
            ("Right", "light", 10),
        ]

    def add(self, word, f):
        self.xl.write_number(self.xl.r)
        self.xl.write_rich(word.before)
        self.xl.write_string(word.simpletext)
        self.xl.write_rich(word.after)
        self.xl.write_string(word.lemma)
        self.xl.write_string(word.lemma)
        self.xl.write_url(word.link(f), f.source.key)
        self.xl.write_string(f.shortname)
        self.xl.write_number(word.line)
        self.xl.write_number(word.char)
        self.xl.write_string(word.tag)
        self.xl.write_string(word.left)
        self.xl.write_string(word.right)
        self.xl.next_row()

    def xl_open(self):
        xlsx = self.key + ".xlsx"
        filename = os.path.join(self.conc.config.output_dir, xlsx)
        self.xl = kexcel.Excel(filename, self.get_columns())

    def xl_close(self):
        self.xl.close()


class Conc():
    def __init__(self, config_file):
        self.log_file = sys.stderr
        self.safenames = naming.safe_naming()
        self.config = kconfig.KConfig(config_file)
        self.source = [Source(self, key, val) for key, val in self.config.source]
        self.search = [Search(self, key, re) for key, re in self.config.search]

    def warn(self, filename, msg):
        print('!', end='', flush=True)
        self.log(filename, msg)

    def log(self, filename, msg):
        print('{}: {}'.format(filename, msg), file=self.log_file, flush=True)

    def log_open(self):
        filename = os.path.join(self.config.output_dir, "log.txt")
        try:
            self.log_file = open(filename, "w")
        except:
            kutil.exception_exit('error creating log file: {}'.format(filename))

    def log_close(self):
        self.log_file.close()
        self.log_file = sys.stderr

    def get_columns(self):
        num = 6
        cols = [
            ("Source",),
            ("File",),
            ("Words",),
        ]
        for s in self.search:
            cols.append(("{} tokens".format(s.key),))
        for s in self.search:
            cols.append(("{} types".format(s.key),))
        return cols

    def add(self, f, words, counts):
        self.xl.write_url(f.url, f.source.key)
        self.xl.write_string(f.shortname)
        self.xl.write_number(words)
        for s in self.search:
            self.xl.write_number(counts[s.key].total)
        for s in self.search:
            self.xl.write_number(counts[s.key].types())
        self.xl.next_row()

    def xl_open(self):
        xlsx = "summary.xlsx"
        filename = os.path.join(self.config.output_dir, xlsx)
        self.xl = kexcel.Excel(filename, self.get_columns())

    def xl_close(self):
        self.xl.close()

    def do(self):
        self.url = 'http://localhost:{}'.format(self.config.server_port)
        try:
            os.makedirs(self.config.output_dir, exist_ok=True)
        except:
            kutil.exception_exit('error creating output directory: {}'.format(self.config.output_dir))
        self.log_open()
        self.xl_open()
        for search in self.search:
            search.xl_open()
        for source in self.source:
            source.process()
        for search in self.search:
            search.xl_close()
        self.xl_close()
        self.log_close()


def main():
    param = sys.argv[1:]
    if len(param) != 1:
        sys.exit('usage: {} CONFIGURATION'.format(sys.argv[0]))
    config_file, = param
    conc = Conc(config_file)
    conc.do()


main()
