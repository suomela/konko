#!/usr/bin/env python3

import collections
import glob
import os
import sys
import xlsxwriter
import lxml.html
from lxml.builder import E
from lxml import etree
import filtering
import naming
import pathabbr
import kconfig
import kutil


CSS = """
.sep, .tag, .del {
    color: #999;
}
.tag, .del {
    font-size: 0.8em;
}
.show {
    color: #00f;
    font-weight: 700;
}
.match {
    color: #d00;
    font-weight: 700;
}
:target {
    color: #0a0;
    font-size: 1.5em;
}
"""


def listglob(globs):
    l = []
    for x in globs:
        g = glob.glob(x)
        if len(g) == 0:
            sys.exit("pattern does not match any file: {}".format(x))
        l += g
    return l


def try_search(re, w, i):
    if re is None:
        return None
    else:
        return re.search(w, i)


def exact_match(re, w):
    m = re.match(w)
    return m is not None and m.start() == 0 and m.end() == len(w)


def try_exact_match(re, w):
    return re is not None and exact_match(re, w)


class Token:
    def html(self):
        i = self.html_id()
        k = self.html_class()
        attr = {}
        if len(k) > 0:
            attr["class"] = " ".join(k)
        if i is not None:
            attr["id"] = i
        if len(attr) > 0:
            return E.span(self.text, **attr)
        else:
            return self.text

    def process0(self):
        self.delete = False
        self.text = filtering.printable_nl(self.raw)
        self.simpletext = filtering.printable_compact(self.raw)


class Word(Token):
    def html_id(self):
        if self.delete:
            return None
        if len(self.match) == 0:
            return None
        return "l{}c{}".format(self.line, self.char)

    def html_class(self):
        k = []
        if self.delete:
            k.append("del")
        elif len(self.match) > 0:
            k.append("match")
        return k

    def link(self, f):
        i = self.html_id()
        assert i is not None
        return '{}#{}'.format(f.url, i)

    def process(self, conc):
        self.lemma = self.simpletext.lower()
        self.match = []
        for search in conc.search:
            if exact_match(search.re, self.raw):
                self.match.append(search)

    def set_context(self, f, i, prev):
        assert f.tokens[i] == self
        if prev is None:
            self.tag = None
        else:
            self.tag = prev.simpletext
        self.before = reversed(self.get_context(f, i, -1))
        self.after = self.get_context(f, i, +1)
        self.left = self.get_context_simple(f, i, -1)
        self.right = self.get_context_simple(f, i, +1)

    def get_context(self, f, i, d):
        ctx = []
        j = i + d
        l = 0
        while 0 <= j < len(f.tokens) and l < f.conc.config.context:
            t = f.tokens[j]
            if not t.delete:
                fmt, txt = t.for_context()
                l += len(txt)
                ctx.append((fmt, txt))
            j += d
        return ctx

    def get_context_simple(self, f, i, d):
        CTX_WORDS = 4
        ctx = []
        j = i + d
        while 0 <= j < len(f.tokens) and len(ctx) < CTX_WORDS:
            t = f.tokens[j]
            if not t.delete and isinstance(t, Word):
                ctx.append(t.simpletext.lower())
            j += d
        return ' '.join(ctx)

    def for_context(self):
        if len(self.match) > 0:
            return "hl", self.simpletext
        else:
            return "normal", self.simpletext


class Tag(Token):
    def html_id(self):
        return None

    def html_class(self):
        k = ["tag"]
        if self.delete:
            k.append("del")
        if self.show_prev:
            k.append("show")
        return k

    def descr(self):
        return 'tag {} on line {}, column {}'.format(self.raw, self.line, self.char)

    def process(self, conc):
        self.show_prev = try_exact_match(conc.config.show_prev, self.raw)
        for a in conc.config.delete:
            if exact_match(a, self.raw):
                self.delete = True
        self.delete_open = []
        self.delete_close = []
        for i, a in enumerate(conc.config.delete_pair):
            a1, a2 = a
            if exact_match(a1, self.raw):
                self.delete_open.append(i)
            if exact_match(a2, self.raw):
                self.delete_close.append(i)

    def for_context(self):
        return "light", self.simpletext


class Sep(Token):
    def html_id(self):
        return None

    def html_class(self):
        return ["sep"]

    def process(self, conc):
        pass

    def for_context(self):
        return "normal", self.simpletext


class Counter:
    def __init__(self):
        self.distinct = set()
        self.total = 0

    def add(self, lemma):
        self.total += 1
        self.distinct.add(lemma)

    def types(self):
        return len(self.distinct)


class File:
    def __init__(self, source, filename, shortname):
        self.source = source
        self.conc = source.conc
        self.filename = filename
        self.shortname = shortname
        self.safename = source.safenames.get(shortname)
        self.htmlfile = self.safename + ".html"
        self.url = source.url + '/' + self.htmlfile
        self.htmlpath = os.path.join(source.htmlpath, self.htmlfile)

    def read(self):
        with open(self.filename, encoding=self.conc.config.encoding) as f:
            self.data = f.read()

    def process(self):
        self.parse()
        self.clean()
        self.report()

    def write(self):
        doc = self.get_html()
        with open(self.htmlpath, "bw") as f:
            f.write(b'<!DOCTYPE html>\n')
            f.write(lxml.html.tostring(doc))
            f.write(b'\n')

    def get_html(self):
        content = [t.html() for t in self.tokens]
        head = E.head(
            E.title(self.shortname),
            E.meta(charset="UTF-8"),
            E.style(CSS),
        )
        body = E.body(E.pre(*content))
        return E.html(head, body, lang="en")

    def parse(self):
        self.tokens = []
        self.line = 1
        self.char = 1
        self.prev = 0
        n = len(self.data)
        while self.prev < n:
            tag = try_search(self.conc.config.tag, self.data, self.prev)
            word = try_search(self.conc.config.word, self.data, self.prev)
            if tag is not None and tag.start() < word.start():
                a = tag.start()
                b = tag.end()
                self.feed(Sep, a)
                self.feed(Tag, b)
            elif word is not None:
                a = word.start()
                b = word.end()
                if tag is not None and tag.start() < b:
                    b = tag.start()
                self.feed(Sep, a)
                self.feed(Word, b)
            else:
                self.feed(Sep, n)

    def feed(self, kind, b):
        a = self.prev
        assert a <= b
        self.prev = b
        if a == b:
            return
        raw = self.data[a:b]
        t = kind()
        t.raw = raw
        t.start = a
        t.line = self.line
        t.char = self.char
        t.process0()
        t.process(self.conc)
        self.tokens.append(t)
        for c in raw:
            if c == '\n':
                self.line += 1
                self.char = 1
            else:
                self.char += 1

    def clean(self):
        m = len(self.conc.config.delete_pair)
        stack = [ [] for x in range(m) ]
        delete_range = []
        for j,t in enumerate(self.tokens):
            if isinstance(t, Tag):
                for x in t.delete_open:
                    stack[x].append(j)
                for x in t.delete_close:
                    if len(stack[x]) == 0:
                        self.conc.warn(self.filename, "{}: no matching opening tag".format(t.descr()))
                    else:
                        i = stack[x].pop()
                        delete_range.append((i,j))
        for l in stack:
            for i in l:
                t = self.tokens[i]
                self.conc.warn(self.filename, "{}: no matching closing tag".format(t.descr()))
        for i,j in delete_range:
            for k in range(i,j+1):
                self.tokens[k].delete = True
        self.words = []
        prev = None
        for i,t in enumerate(self.tokens):
            if isinstance(t, Tag) and not t.delete and t.show_prev:
                prev = t
            if isinstance(t, Word) and not t.delete:
                self.words.append(t)
                if len(t.match) > 0:
                    t.set_context(self, i, prev)

    def report(self):
        counts = { s.key: Counter() for s in self.conc.search }
        for w in self.words:
            for s in w.match:
                counts[s.key].add(w.lemma)
                s.add(w, self)
        self.conc.add(self, len(self.words), counts)


class Source:
    def __init__(self, conc, key, globs):
        self.conc = conc
        self.key = key
        self.globs = globs
        self.safename = conc.safenames.get(key)
        self.safenames = naming.safe_naming()

    def process(self):
        self.url = self.conc.url + '/' + self.safename
        self.htmlpath = os.path.join(self.conc.config.output_dir, self.safename)
        try:
            os.makedirs(self.htmlpath, exist_ok=True)
        except:
            kutil.exception_exit('error creating output directory: {}'.format(self.htmlpath))
        print(self.key, end=' ', flush=True)
        skip = set(listglob(self.conc.config.skip_files))
        l = listglob(self.globs)
        l = [x for x in l if x not in skip]
        if len(l) == 0:
            sys.exit("{}: after skipping, there are no files left".format(self.key))
        shortnames = pathabbr.pathabbr(l)
        self.files = []
        for filename in l:
            print('.', end='', flush=True)
            f = File(self, filename, shortnames[filename])
            self.files.append(f)
            try:
                f.read()
            except:
                print()
                kutil.exception_exit('error reading input file: {}'.format(filename))
            f.process()
            try:
                f.write()
            except:
                print()
                kutil.exception_exit('error writing output file: {}'.format(f.htmlfile))
        print()


class Excel:
    def define_formats(self):
        self.fmt_bold = self.wb.add_format({'bold': True})
        self.fmt_hl = self.wb.add_format({'bold': True, 'font_color': '#dd0000'})
        self.fmt_word = self.wb.add_format({'align': 'center', 'bold': True})
        self.fmt_right = self.wb.add_format({'align': 'right'})
        self.fmt_light = self.wb.add_format({'font_color': '#999999'})

    def wb_open_helper(self, filename):
        try:
            self.wb = xlsxwriter.Workbook(filename)
        except:
            kutil.exception_exit('error creating output file: {}'.format(filename))
        self.define_formats()
        self.ws = self.wb.add_worksheet()
        self.widths = collections.defaultdict(int)
        self.r = 1

    def wb_close(self):
        self.ws.set_row(0, None, self.fmt_bold)
        cols = self.get_columns()
        self.r = 0
        for c, col in enumerate(cols):
            name = col[0]
            self.write_string(c, name)
        for c, col in enumerate(cols):
            fmt = col[1] if len(col) > 1 else None
            width = col[2] if len(col) > 2 else None
            if width is None:
                width = self.autoscale(c)
            if fmt is None:
                self.ws.set_column(c, c, width)
            else:
                self.ws.set_column(c, c, width, fmt)
        self.ws.freeze_panes(1, 0)
        self.wb.close()

    def autoscale(self, c):
        t = 10
        k = 0.8
        w = self.widths[c] + 1
        if w > t:
            w = t + int(k * (w - t))
        return w

    def tell(self, c, w):
        self.widths[c] = max(self.widths[c], w)

    def write_number(self, c, v):
        self.ws.write_number(self.r, c, v)
        self.tell(c, len(str(v)))

    def write_string(self, c, v):
        self.ws.write_string(self.r, c, v)
        self.tell(c, len(v))

    def write_url(self, c, url, v):
        self.ws.write_url(self.r, c, url, None, v)
        self.tell(c, len(v))

    def write_rich(self, c, v):
        l = []
        s = ""
        for fmt, txt in v:
            if fmt == "light":
                l.append(self.fmt_light)
                l.append(txt)
            elif fmt == "hl":
                l.append(self.fmt_hl)
                l.append(txt)
            elif fmt == "normal":
                l.append(txt)
            else:
                assert False, fmt
            s += txt
        if len(l) > 0:
            self.ws.write_rich_string(self.r, c, *l)
        self.tell(c, len(s))


class Search(Excel):
    def __init__(self, conc, key, re):
        self.key = key
        self.re = re
        self.conc = conc

    def get_columns(self):
        return [
            ("N",),
            ("Before", self.fmt_right),
            ("Word", self.fmt_word),
            ("After",),
            ("Simple",),
            ("Lemma",),
            ("Source",),
            ("File",),
            ("Line",),
            ("Column",),
            ("Tag",),
            ("Left", self.fmt_light, 10),
            ("Right", self.fmt_light, 10),
        ]

    def add(self, word, f):
        self.write_number(0, self.r)
        self.write_rich(1, word.before)
        self.write_string(2, word.simpletext)
        self.write_rich(3, word.after)
        self.write_string(4, word.lemma)
        self.write_string(5, word.lemma)
        self.write_url(6, word.link(f), f.source.key)
        self.write_string(7, f.shortname)
        self.write_number(8, word.line)
        self.write_number(9, word.char)
        if word.tag is not None:
            self.write_string(10, word.tag)
        self.write_string(11, word.left)
        self.write_string(12, word.right)
        self.r += 1

    def wb_open(self):
        xlsx = self.key + ".xlsx"
        filename = os.path.join(self.conc.config.output_dir, xlsx)
        self.wb_open_helper(filename)


class Conc(Excel):
    def __init__(self, config_file):
        self.log_file = sys.stderr
        self.safenames = naming.safe_naming()
        self.config = kconfig.KConfig(config_file)
        self.source = [Source(self, key, val) for key, val in self.config.source]
        self.search = [Search(self, key, re) for key, re in self.config.search]

    def warn(self, filename, msg):
        print('!', end='', flush=True)
        self.log(filename, msg)

    def log(self, filename, msg):
        print('{}: {}'.format(filename, msg), file=self.log_file, flush=True)

    def log_open(self):
        filename = os.path.join(self.config.output_dir, "log.txt")
        try:
            self.log_file = open(filename, "w")
        except:
            kutil.exception_exit('error creating log file: {}'.format(filename))

    def log_close(self):
        self.log_file.close()
        self.log_file = sys.stderr

    def get_columns(self):
        num = 6
        cols = [
            ("Source",),
            ("File",),
            ("Words",),
        ]
        for s in self.search:
            cols.append(("{} tokens".format(s.key),))
        for s in self.search:
            cols.append(("{} types".format(s.key),))
        return cols

    def add(self, f, words, counts):
        self.write_url(0, f.url, f.source.key)
        self.write_string(1, f.shortname)
        self.write_number(2, words)
        c = 3
        for s in self.search:
            self.write_number(c, counts[s.key].total)
            c += 1
        for s in self.search:
            self.write_number(c, counts[s.key].types())
            c += 1
        self.r += 1

    def wb_open(self):
        xlsx = "summary.xlsx"
        filename = os.path.join(self.config.output_dir, xlsx)
        self.wb_open_helper(filename)

    def do(self):
        self.url = 'http://localhost:{}'.format(self.config.server_port)
        try:
            os.makedirs(self.config.output_dir, exist_ok=True)
        except:
            kutil.exception_exit('error creating output directory: {}'.format(self.config.output_dir))
        self.log_open()
        self.wb_open()
        for search in self.search:
            search.wb_open()
        for source in self.source:
            source.process()
        for search in self.search:
            search.wb_close()
        self.wb_close()
        self.log_close()


def main():
    param = sys.argv[1:]
    if len(param) != 1:
        sys.exit('usage: {} CONFIGURATION'.format(sys.argv[0]))
    config_file, = param
    conc = Conc(config_file)
    conc.do()


main()
